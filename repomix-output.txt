This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-06T22:19:09.914Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
client1_file3
client2_file1
client3_file1
in1.txt
in2.txt
in3.txt
main.cpp
Makefile
peer.cpp
peer.h
tracker.cpp
tracker.h
utils.h

================================================================
Files
================================================================

================
File: client1_file3
================
hash_file_3_0
hash_file_3_1
hash_file_3_2
hash_file_3_3

hash_file_3_0
hash_file_3_1
hash_file_3_2
hash_file_3_3

hash_file_3_0
hash_file_3_1
hash_file_3_2
hash_file_3_3

hash_file_3_0
hash_file_3_1
hash_file_3_2
hash_file_3_3

hash_file_3_0
hash_file_3_1
hash_file_3_2
hash_file_3_3

hash_file_3_0
hash_file_3_1
hash_file_3_2
hash_file_3_3

hash_file_3_0
hash_file_3_1
hash_file_3_2
hash_file_3_3

hash_file_3_0
hash_file_3_1
hash_file_3_2
hash_file_3_3

hash_file_3_0
hash_file_3_1
hash_file_3_2
hash_file_3_3

================
File: client2_file1
================
hash_file_1_0
hash_file_1_1
hash_file_1_2
hash_file_1_3

hash_file_1_0
hash_file_1_1
hash_file_1_2
hash_file_1_3

hash_file_1_0
hash_file_1_1
hash_file_1_2
hash_file_1_3

hash_file_1_0
hash_file_1_1
hash_file_1_2
hash_file_1_3

hash_file_1_0
hash_file_1_1
hash_file_1_2
hash_file_1_3

hash_file_1_0
hash_file_1_1
hash_file_1_2
hash_file_1_3

================
File: client3_file1
================
hash_file_1_0
hash_file_1_1
hash_file_1_2
hash_file_1_3

hash_file_1_0
hash_file_1_1
hash_file_1_2
hash_file_1_3

hash_file_1_0
hash_file_1_1
hash_file_1_2
hash_file_1_3

hash_file_1_0
hash_file_1_1
hash_file_1_2
hash_file_1_3

hash_file_1_0
hash_file_1_1
hash_file_1_2
hash_file_1_3

hash_file_1_0
hash_file_1_1
hash_file_1_2
hash_file_1_3

================
File: in1.txt
================
2
file1 4
hash_file_1_0
hash_file_1_1
hash_file_1_2
hash_file_1_3

file2 4
hash_file_2_0
hash_file_2_1
hash_file_2_2
hash_file_2_3

1
file3

================
File: in2.txt
================
1
file3 4
hash_file_3_0
hash_file_3_1
hash_file_3_2
hash_file_3_3
1
file1

================
File: in3.txt
================
0
3
file1
file2
file3

================
File: main.cpp
================
#include <mpi.h>
#include <thread>
#include <stdio.h>
#include <stdlib.h>
#include <fstream>
#include <vector>
#include <unordered_map>

#include "peer.h"
#include "tracker.h"
#include "utils.h"


int main(int argc, char *argv[]) {
    int numtasks, rank;
 
    int provided;
    MPI_Init_thread(&argc, &argv, MPI_THREAD_MULTIPLE, &provided);
    if (provided < MPI_THREAD_MULTIPLE) {
        fprintf(stderr, "MPI nu are suport pentru multi-threading\n");
        exit(-1);
    }
    MPI_Comm_size(MPI_COMM_WORLD, &numtasks);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);

    if (rank == TRACKER_RANK) {
		auto tracker = Tracker(numtasks, rank);
        tracker.init();
    } else {
		auto peer = Peer(numtasks, rank);
        peer.init();
    }

    MPI_Finalize();
}

================
File: Makefile
================
CC = mpic++
FLAGS = -Wall

build: tema2

tema2: main.o peer.o tracker.o
	$(CC) $^ -o $@ $(FLAGS)

main.o: main.cpp utils.h
	$(CC) -c $< $(FLAGS)

peer.o: peer.cpp peer.h utils.h
	$(CC) -c $< $(FLAGS)

tracker.o: tracker.cpp tracker.h utils.h
	$(CC) -c $< $(FLAGS)

clean:
	rm -rf tema2 main.o peer.o tracker.o

================
File: peer.cpp
================
#include "peer.h"

#include <mpi.h>
#include <thread>
#include <stdio.h>
#include <stdlib.h>
#include <fstream>
#include <vector>
#include <unordered_map>
#include <sstream>
#include <algorithm>

#include "utils.h"

using namespace std;

void Peer::init() {
	parse_initial_files();

	send_owned_files_to_tracker();

	start_and_join_threads();
}

void Peer::start_and_join_threads() {
	thread download_thread(&Peer::download_thread_func, this);
	thread upload_thread(&Peer::upload_thread_func, this);

	download_thread.join();
	upload_thread.join();
}

void Peer::download_thread_func() {
    // Wait for the initial ACK from the tracker.
    int ack;
    MPI_Recv(&ack, 1, MPI_INT, TRACKER_RANK, TRACKER_TAG, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
    if (ack != 1) {
        cout << "Tracker did not send OK message." << endl;
        exit(-1);
    }
	cout << "Got the ACK: " << rank << endl;

    // For each file that this peer wants:
    for (auto &wanted_file_name : wanted_files) {
        // 1) Get the swarm from the tracker
        req_file_swarm_from_tracker(wanted_file_name);
        vector<int> file_owners = recv_file_swarm_from_tracker(wanted_file_name);
		cout << "[Peer " << rank << "]: Got swarm for file " << wanted_file_name << " received." << endl;
		// print the swarm
		cout << "Swarm for file " << wanted_file_name << " is: ";
		for (auto owner : file_owners) {
			cout << owner << " ";
		}
		cout << endl;
        if (file_owners.empty()) {
            cerr << "[Peer " << rank << "]: No swarm found for file "
                 << wanted_file_name << ". Cannot download.\n";
            continue;
        }

        // 2) Gather all segment hashes we need (assuming you have them somewhere)
        vector<string> hashes_to_acquire = wanted_files_hashes[wanted_file_name];
        int total_segments_for_file = (int)hashes_to_acquire.size();

        // 3) Download each segment
        for (int seg_idx = 0; seg_idx < total_segments_for_file; seg_idx++) {
            const string &segment_hash = hashes_to_acquire[seg_idx];

            // Round-robin among file_owners
            bool segment_downloaded = false;
            int attempts = 0;

            while (!segment_downloaded && attempts < (int)file_owners.size()) {
                int peer_index = (seg_idx + attempts) % file_owners.size();
                int target_peer = file_owners[peer_index];
				if (target_peer == rank) {
					continue;
				}
				string buf = wanted_file_name + " " + segment_hash;
				// send the size
				int size = buf.size();
				MPI_Send(&size, 1, MPI_INT, target_peer, UPLOAD_TAG, MPI_COMM_WORLD);
				// debug that im requesting from the right peer
				cout << "[Peer " << rank << "]: Requesting segment " << segment_hash << " from peer " << target_peer << endl;
                // Request the segment
                MPI_Send(buf.c_str(), buf.size(), MPI_CHAR, 
                         target_peer, UPLOAD_TAG, MPI_COMM_WORLD);

                // Wait for the response (ACK == OK, else considered NACK)
                int response;
                MPI_Recv(&response, 1, MPI_INT, target_peer, DOWNLOAD_TAG, 
                         MPI_COMM_WORLD, MPI_STATUS_IGNORE);

                if (response == OK) {
                    // We have successfully downloaded the segment
					cout << "[Peer " << rank << "]: Successfully downloaded segment " << segment_hash << "from peer" << target_peer << endl;
                    mtx.lock();
					owned_files[wanted_file_name].push_back(segment_hash);
                    mtx.unlock();
                    segment_count++;
                    segment_downloaded = true;

                    // After every 10 new segments, notify tracker and re-fetch the swarm
                    if (segment_count % 10 == 0) {
                        send_peer_update_to_tracker(wanted_file_name);

                        // Re-request the swarm to check if new complete owners joined
                        req_file_swarm_from_tracker(wanted_file_name);
                        file_owners = recv_file_swarm_from_tracker(wanted_file_name);
                    }
                } // else NACK => try next peer in the round-robin
                attempts++;
            }

            if (!segment_downloaded) {
                cerr << "[Peer " << rank << "] Failed to download segment "
                     << segment_hash << " of file " << wanted_file_name << endl;
            }
        }

        // 4) Notify tracker: we now have the entire file
        send_download_completed_to_tracker(wanted_file_name);
        save_file(wanted_file_name);
    }

    // 5) Finally, notify tracker that we have finished all our downloads
	cout << "[Peer " << rank << "]: Finished all downloads." << endl;
    send_all_downloads_completed_to_tracker();
}

void Peer::send_all_downloads_completed_to_tracker() {
	int action = ALL_DOWNLOADS_COMPLETED;
	MPI_Send(&action, 1, MPI_INT, TRACKER_RANK, TRACKER_TAG, MPI_COMM_WORLD);
}

void Peer::send_peer_update_to_tracker(string wanted_file_name) {
	string buffer = wanted_file_name;
	int size = buffer.size();
	MPI_Send(&size, 1, MPI_INT, TRACKER_RANK, TRACKER_TAG, MPI_COMM_WORLD);
	MPI_Send(buffer.c_str(), buffer.size(), MPI_CHAR, TRACKER_RANK, TRACKER_TAG, MPI_COMM_WORLD);
}

void Peer::send_download_completed_to_tracker(string file_name) {
	string buf = file_name;
	int action = DOWNLOAD_COMPLETED;
	MPI_Send(&action, 1, MPI_INT, TRACKER_RANK, TRACKER_TAG, MPI_COMM_WORLD);
	int size = buf.size();
	MPI_Send(&size, 1, MPI_INT, TRACKER_RANK, TRACKER_TAG, MPI_COMM_WORLD);
	MPI_Send(buf.c_str(), buf.size(), MPI_CHAR, TRACKER_RANK, TRACKER_TAG, MPI_COMM_WORLD);
}

void Peer::upload_thread_func() {
	while (1) {
		// wait for request
		int size;
		MPI_Status status;
		MPI_Recv(&size, 1, MPI_INT, MPI_ANY_SOURCE, UPLOAD_TAG, MPI_COMM_WORLD, &status);
		int source = status.MPI_SOURCE;
		char buf[size + 1];
		string file_name;
		string segment_hash;
		MPI_Recv(buf, size, MPI_CHAR, source, UPLOAD_TAG, MPI_COMM_WORLD, &status);
		buf[size] = '\0';
		// debug that im requestion from the right peer
		cout << "[Peer " << rank << "]: Received request for segment " << buf << " from peer " << source << endl;
		stringstream ss(buf);
		ss >> file_name >> segment_hash;

		if (file_name == "TERMINATE") {
			break;
		}
		mtx.lock();
		/* Check if we have the wanted segment, if yes send ACK, if not send NACK */
		if (find(owned_files[file_name].begin(), owned_files[file_name].end(), segment_hash) != owned_files[file_name].end()) {
			int response = OK;
			cout << "[Peer " << rank << "]: Sending segment " << segment_hash << " to peer " << source << endl;
			MPI_Send(&response, 1, MPI_INT, source, DOWNLOAD_TAG, MPI_COMM_WORLD);
		} else {
			int response = !OK;
			MPI_Send(&response, 1, MPI_INT, source, DOWNLOAD_TAG, MPI_COMM_WORLD);
		}
		mtx.unlock();
	}

	#ifdef DEBUG
	cout << "[Uploading]: Peer " << rank << " Upload thread finished." << endl;
	#endif
}

void Peer::parse_initial_files() {
	ifstream fin("in" + to_string(rank) + ".txt");
	int segment_nr;
	string file_name;
	string segment_hash;
	int file_count;
	// read owned files
	fin >> file_count;
	for (int i = 0; i < file_count; i++) {
		fin >> file_name >> segment_nr;
		for (int j = 1; j <= segment_nr; j++) {
			fin >> segment_hash;
			owned_files[file_name].push_back(segment_hash);
		}
	}

	// read wanted files
	fin >> file_count;
	for (int i = 0; i < file_count; i++) {
		fin >> file_name;
		wanted_files.push_back(file_name);
	}
	fin.close();
}

vector<int> Peer::recv_file_swarm_from_tracker(string file_name) {
	int buf_size;
	MPI_Recv(&buf_size, 1, MPI_INT, TRACKER_RANK, TRACKER_TAG, MPI_COMM_WORLD, MPI_STATUS_IGNORE);

	char response_buf[buf_size + 1];
	MPI_Recv(response_buf, buf_size, MPI_CHAR, TRACKER_RANK, TRACKER_TAG, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
	response_buf[buf_size] = '\0';
	// return the list of seeds/peers
	vector<int> file_owners;
	stringstream file_owners_str(response_buf);
	int owners_count;
	int rank;
	file_owners_str >> owners_count;
	for (int i = 0; i < owners_count; i++) {
		file_owners_str >> rank;
		file_owners.emplace_back(rank);
	}
	if (wanted_files_hashes[file_name].empty()) {
		int segment_count;
		file_owners_str >> segment_count;
		for (int i = 0; i < segment_count; i++) {
			string segment_hash;
			file_owners_str >> segment_hash;
			wanted_files_hashes[file_name].push_back(segment_hash);
		}
	}
	return file_owners;
}

void Peer::req_file_swarm_from_tracker(string file_name) {
	int file_name_size = file_name.size();

	// Request the file's swarm from the tracker
	MPI_Send(&FILE_REQUEST, 1, MPI_INT, TRACKER_RANK, TRACKER_TAG, MPI_COMM_WORLD);
	MPI_Send(&file_name_size, 1, MPI_INT, TRACKER_RANK, TRACKER_TAG, MPI_COMM_WORLD);
	MPI_Send(file_name.c_str(), file_name.size(), MPI_CHAR, TRACKER_RANK, TRACKER_TAG, MPI_COMM_WORLD);
}

/* Sends the initial file hashes to the tracker 
 * The client will act as a SEED for these files */
void Peer::send_owned_files_to_tracker() {
	string buffer = to_string(owned_files.size()) + " ";
	for (auto &[file_name, hashes] : owned_files) {
		buffer += file_name + " " + to_string(hashes.size()) + " ";
		for (auto hash : hashes) {
			buffer += hash + " ";
		}
	}

	int size = buffer.size();
	// send the list of owned files to the tracker
	MPI_Send(&size, 1, MPI_INT, TRACKER_RANK, TRACKER_TAG, MPI_COMM_WORLD);
	MPI_Send(buffer.c_str(), buffer.size(), MPI_CHAR, TRACKER_RANK, TRACKER_TAG, MPI_COMM_WORLD);
}

void Peer::save_file(string wanted_file_name) {
	ofstream fout("client" + to_string(rank)+ "_" + wanted_file_name, ios::app);
	for (auto hash : owned_files[wanted_file_name]) {
		fout << hash << "\n";
	}
	fout << endl;
	fout.close();
}

================
File: peer.h
================
#pragma once

#include <thread>
#include <vector>
#include <stdlib.h>
#include <fstream>
#include <stdio.h>
#include <unordered_map>
#include <string>
#include <mpi.h>
#include "utils.h"
#include <mutex>

using namespace std;

class Peer {
private:
	int num_tasks;
	int rank;
	mutex mtx;

	unordered_map<string, vector<string>> wanted_files_hashes;

	unordered_map<string, vector<string>> owned_files;
	vector<string> wanted_files;
	int segment_count;

	void download_thread_func();

    void upload_thread_func();
	
	void req_file_swarm_from_tracker(string file_name);
	
	void save_file(string wanted_file_name);

	void send_peer_update_to_tracker(string wanted_file_name);

	void send_download_completed_to_tracker(string file_name);

	void send_all_downloads_completed_to_tracker();
	
	void parse_initial_files();

	void send_initial_files_to_tracker();

	vector<int> recv_file_swarm_from_tracker(string file_name);

	void send_owned_files_to_tracker();
	
	void start_and_join_threads();

public:
	Peer(int numtasks, int rank) : num_tasks(numtasks), rank(rank), segment_count(0) {}

	void init();

};

================
File: tracker.cpp
================
#include "tracker.h"

#include <mpi.h>
#include <thread>
#include <stdio.h>
#include <stdlib.h>
#include <fstream>
#include <vector>
#include <unordered_map>
#include <sstream>
#include <algorithm>

using namespace std;

void Tracker::init() {
	receive_initial_files_from_clients();
	
	acknowledge_initial_files();
	
	start_mediating_the_swarms();

	signal_all_seeds_to_terminate();
}

/* The Tracker assumes the intermediary role of updating each file's swarm
 * and signaling the clients accordingly as long as there is at least one
 * peer remaining, that is, not all of the clients become seeds */
void Tracker::start_mediating_the_swarms() {
	int client_count = num_tasks - 1;
	while (downloads_completed_nr_ < client_count) {
		MPI_Status status;
		int type;
		MPI_Recv(&type, 1, MPI_INT, MPI_ANY_SOURCE, TRACKER_TAG, MPI_COMM_WORLD, &status);

		// check the type of message received from client
		switch(type) {
			case FILE_REQUEST:
				file_request(status.MPI_SOURCE);
				break;
			case PEER_UPDATE:
				peer_update(status.MPI_SOURCE);
				break;
			case DOWNLOAD_COMPLETED:
				download_completed(status.MPI_SOURCE);
				break;
			case ALL_DOWNLOADS_COMPLETED:
				all_downloads_completed(status.MPI_SOURCE);
				break;
		}
	}
	signal_all_seeds_to_terminate();
}

/* Once all clients become seeds, there are no more clients which demand segments
 * so just notify all clients to close their upload thread and terminate */
void Tracker::signal_all_seeds_to_terminate() {
	string terminate = "TERMINATE";
	int size = terminate.size();
	for (int i = 1; i < num_tasks; i++) {
		MPI_Send(&size, 1, MPI_INT, i, UPLOAD_TAG, MPI_COMM_WORLD);
		MPI_Send(terminate.c_str(), terminate.size(), MPI_CHAR, i, UPLOAD_TAG, MPI_COMM_WORLD);
	}
}

void Tracker::acknowledge_initial_files() {
	// when received all lists, send OK to all clients
	int ack = 1;
	for (int i = 1; i < num_tasks; i++) {
		MPI_Send(&ack, 1, MPI_INT, i, TRACKER_TAG, MPI_COMM_WORLD);
	}
}

string Tracker::get_file_swarm(string file_name) {
    string swarm;
	vector<int>& owners = swarms[file_name];

	/* Number of owners in the swarm */
	swarm += to_string(owners.size()) + " ";
	/* File owner's rank */
	for (auto owner : owners) {
		swarm += to_string(owner) + " ";
	}
	
	return swarm;
}

void Tracker::file_request(int source) {
	int size;

	// get the name of the requested file
	MPI_Recv(&size, 1, MPI_INT, source, TRACKER_TAG, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
	char buf[size + 1];
	MPI_Recv(buf, size, MPI_CHAR, source, TRACKER_TAG, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
	buf[size] = '\0';
	string file_name(buf);

	string swarm = get_file_swarm(file_name);

	/* Now add the file's hashes so the client can verify correctness */
	swarm += to_string(file_content[file_name].size()) + " ";
	for (auto hash : file_content[file_name]) {
		swarm += hash + " ";
	}

	// send the response to the client
	cout << "[TRACKER]: Sending swarm for file " << file_name << " to " << source << endl;
	size = swarm.size();
	MPI_Send(&size, 1, MPI_INT, source, TRACKER_TAG, MPI_COMM_WORLD);
	MPI_Send(swarm.c_str(), swarm.size(), MPI_CHAR, source, TRACKER_TAG, MPI_COMM_WORLD);
}

void Tracker::peer_update(int client_rank) {
	int buf_size;
	MPI_Recv(&buf_size, 1, MPI_INT, client_rank, TRACKER_TAG, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
	char buf[buf_size + 1];
	MPI_Recv(buf, buf_size, MPI_CHAR, client_rank, TRACKER_TAG, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
	buf[buf_size] = '\0';
	string file_name(buf);
	if (swarms.find(file_name) == swarms.end()) {
		swarms[file_name].push_back(client_rank);
	}
}

void Tracker::receive_initial_files_from_clients() {
    for (int r = 1; r < num_tasks; r++) {
        seed_initial_update(r);
    }
}

void Tracker::seed_initial_update(int source) {
	// get the list of owned files from the client
	int size;
	MPI_Recv(&size, 1, MPI_INT, source, TRACKER_TAG, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
	char buf[size + 1];
	MPI_Recv(buf, size, MPI_CHAR, source, TRACKER_TAG, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
	buf[size] = '\0';
	// parse the list of owned files
	string file_list(buf);
	parse_peer_file_list(file_list, source);
}

void Tracker::download_completed(int client_rank) {
	/* TODO: mark the client as seed, pretty useless in my implementation */
}

void Tracker::all_downloads_completed(int source) {
	// update the number of clients that finished downloading all their files
	downloads_completed_nr_++;
}

void Tracker::parse_peer_file_list(string file_list, int rank) {
	stringstream ss(file_list);

	string file_name;
	string segment_hash;
	int files_nr;
	int segment_nr;

	// parse the list of owned files
	ss >> files_nr;
	while (ss >> file_name) {
		swarms[file_name].push_back(rank);
		ss >> segment_nr;
		for (int i = 1; i <= segment_nr; i++) {
			ss >> segment_hash;
			file_content[file_name].push_back(segment_hash);
		}
	}
}

================
File: tracker.h
================
#pragma once

#include <mpi.h>
#include <thread>
#include <stdio.h>
#include <stdlib.h>
#include <fstream>
#include <vector>
#include <unordered_map>

#include "utils.h"

using namespace std;

class Tracker {
private:
	int num_tasks;
	int rank_;
	int downloads_completed_nr_ = 0;

	unordered_map<string, vector<string>> file_content;

    unordered_map<string, vector<int>> swarms;

	void file_request(int source);
	
	void acknowledge_initial_files();

	void start_mediating_the_swarms();

	void signal_all_seeds_to_terminate();

	void seed_initial_update(int source);

	string get_file_swarm(string file_name);

	void peer_update(int source);
	
	void receive_initial_files_from_clients();

	void download_completed(int source);
	
	void all_downloads_completed(int source);
	
	void parse_peer_file_list(string file_list, int rank);

public:
	Tracker(int numtasks, int rank) {
		num_tasks = numtasks;
		rank_ = rank;
	}

	void init();
};

================
File: utils.h
================
#pragma once

#include <string>

constexpr int TRACKER_RANK = 0;
constexpr int MAX_FILES = 10;
constexpr int MAX_FILENAME = 15;
constexpr int HASH_SIZE = 32;
constexpr int MAX_CHUNKS = 100;

constexpr int OK = 1;

constexpr int FILE_REQUEST = 2;
constexpr int PEER_UPDATE = 3;
constexpr int DOWNLOAD_COMPLETED = 4;
constexpr int ALL_DOWNLOADS_COMPLETED = 5;

constexpr int TRACKER_TAG = 1;
constexpr int DOWNLOAD_TAG = 2;
constexpr int UPLOAD_TAG = 3;

const std::string POISON_HASH = "-------------------------------";

struct Segment {
	int nr;
	std::string hash;

	Segment(int nr, std::string hash) : nr(nr), hash(hash) {}

	bool operator==(const Segment& other) const {
        return hash == other.hash;
    }
};

template <>
struct std::hash<Segment> {
    std::size_t operator()(const Segment& segment) const {
		return std::hash<std::string>()(segment.hash);
	}
};
